<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TaylorIntegration.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TaylorIntegration.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Background</span><ul><li><a class="toctext" href="taylor_method.html">ODE integration using Taylor&#39;s method</a></li><li><a class="toctext" href="lyapunov_spectrum.html">Lyapunov spectrum</a></li><li><a class="toctext" href="jet_transport.html">Jet transport</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="simple_example.html">Infinity in finite time</a></li><li><a class="toctext" href="kepler.html">The Kepler problem</a></li><li><a class="toctext" href="lorenz_lyapunov.html">Lyapunov spectrum of Lorenz system</a></li><li><a class="toctext" href="pendulum.html">Jet transport: the simple pendulum</a></li><li><a class="toctext" href="root_finding.html">Poincaré maps</a></li><li><a class="toctext" href="common.html">Interoperability with <code>DifferentialEquations.jl</code></a></li></ul></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"><li><a class="toctext" href="#Exported-functions-1">Exported functions</a></li><li><a class="toctext" href="#Internal-1">Internal</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Library-1" href="#Library-1">Library</a></h1><hr/><h2><a class="nav-anchor" id="Exported-functions-1" href="#Exported-functions-1">Exported functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.lyap_taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Array{U,1},T,T,Int64,T}, Tuple{Any,Array{U,1},T,T,Int64,T,Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.lyap_taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Array{U,1},T,T,Int64,T}, Tuple{Any,Array{U,1},T,T,Int64,T,Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_taylorinteg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lyap_taylorinteg(f!, q0, t0, tmax, order, abstol[, f!]; maxsteps::Int=500)</code></pre><p>Similar to <a href="api.html#TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Any,Array{U,1},T,T,Int64,T}} where U&lt;:Number where T&lt;:Real"><code>taylorinteg</code></a> for the calculation of the Lyapunov spectrum. Note that the number of <code>TaylorN</code> variables should be set previously by the user (e.g., by means of <code>TaylorSeries.set_variables</code>) and should be equal to the length of the vector of initial conditions <code>q0</code>. Otherwise, whenever <code>length(q0) != TaylorSeries.get_numvars()</code>, then <code>lyap_taylorinteg</code> throws an <code>AssertionError</code>. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to evaluate the current value of the Jacobian. Otherwise, the current value of the Jacobian is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/lyapunovspectrum.jl#L190-L203">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Any,Array{U,1},T,T,Int64,T}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Any,Array{U,1},T,T,Int64,T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.taylorinteg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">taylorinteg(f, g, x0, t0, tmax, order, abstol; kwargs... )</code></pre><p>Root-finding method of <code>taylorinteg</code>. Given a function <code>g(t, x, dx)</code>, called the event function, <code>taylorinteg</code> checks for the occurrence of a root of <code>g</code> evaluated at the solution; that is, it checks for the occurrence of an event or condition specified by <code>g=0</code>. Then, <code>taylorinteg</code> attempts to find that root (or event, or crossing) by performing a Newton-Raphson process. When called with the <code>eventorder=n</code> keyword argument, <code>taylorinteg</code> searches for the roots of the <code>n</code>-th derivative of <code>g</code>, which is computed via automatic differentiation.</p><p><code>maxsteps</code> is the maximum number of allowed time steps; <code>eventorder</code> is the order of the derivatives of <code>g</code> whose roots the user is interested in finding; <code>newtoniter</code> is the maximum number of Newton-Raphson iterations per detected root; <code>nrabstol</code> is the allowed tolerance for the Newton-Raphson process.</p><p>The current keyword arguments are <code>maxsteps=500</code>, <code>eventorder=0</code>, <code>newtoniter=10</code>, and <code>nrabstol=eps(T)</code>, where <code>T</code> is the common type of <code>t0</code>, <code>tmax</code> and <code>abstol</code>.</p><p>For more details about conventions in <code>taylorinteg</code>, please see <a href="api.html#TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Any,Array{U,1},T,T,Int64,T}} where U&lt;:Number where T&lt;:Real"><code>taylorinteg</code></a>.</p><p><strong>Examples</strong>:</p><pre><code class="language-julia">    using TaylorIntegration

    function pendulum!(t, x, dx)
        dx[1] = x[2]
        dx[2] = -sin(x[1])
        nothing
    end

    g(t, x, dx) = x[2]

    x0 = [1.3, 0.0]

    # find the roots of `g` along the solution
    tv, xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, 0.0, 22.0, 28, 1.0E-20);

    # find the roots of the 2nd derivative of `g` along the solution
    tv, xv, tvS, xvS, gvS = taylorinteg(pendulum!, g, x0, 0.0, 22.0, 28, 1.0E-20; eventorder=2);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/rootfinding.jl#L95-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,U,Union{AbstractRange{T}, Array{T,1}},Int64,T}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,U,Union{AbstractRange{T}, Array{T,1}},Int64,T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.taylorinteg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">taylorinteg(f, x0, t0, trange, order, abstol; keyword... )</code></pre><p>General-purpose Taylor integrator for the explicit ODE <span>$\dot{x}=f(t,x)$</span> with initial condition specified by <code>x0::{T&lt;:Number}</code> or <code>x0::Vector{T}</code> at time <code>t0</code>. It returns a vector (of type <code>typeof(x0)</code>) with the computed values of the dependent variable(s), evaluated <em>only</em> at the times specified by the range <code>trange</code>. The integration stops at <code>tmax=trange[end]</code> (in which case the last returned values are <code>t_max</code>, <code>x(t_max)</code>), or else when the number of computed time steps is larger than <code>maxsteps</code>.</p><p>The integration uses polynomial expansions on the independent variable of order <code>order</code>; the parameter <code>abstol</code> serves to define the time step using the last two Taylor coefficients of the expansions. Make sure you use a <em>large enough</em> <code>order</code> to assure convergence.</p><p>The current keyword argument is <code>maxsteps=500</code>.</p><p><strong>Examples</strong>:</p><ul><li>One dependent variable: The function <code>f</code> defines the equation of motion.</li></ul><pre><code class="language-julia">    using TaylorIntegration

    f(t, x) = x^2

    xv = taylorinteg(f, 3.0, 0.0:0.001:0.3, 25, 1.0e-20, maxsteps=100 )</code></pre><ul><li>Many (two or more) dependent variable: The function f! defines the   equation of motion.</li></ul><pre><code class="language-julia">    using TaylorIntegration

    function f!(t, x, dx)
        for i in eachindex(x)
            dx[i] = x[i]^2
        end
    end

    xv = taylorinteg(f!, [3.0, 3.0], 0.0:0.001:0.3, 25, 1.0e-20, maxsteps=100 )</code></pre><p>Note that f! updates (mutates) the pre-allocated vector dx.</p><ul><li>Jet transport for the simple pendulum.</li></ul><pre><code class="language-julia">    using TaylorIntegration # TaylorSeries is reexported automatically

    function pendulum!(t, x, dx) #the simple pendulum ODE
        dx[1] = x[2]
        dx[2] = -sin(x[1])
    end

    p = set_variables(&quot;ξ&quot;, numvars=2, order=5) #TaylorN set-up, order 5
    q0 = [1.3, 0.0]    # initial conditions
    q0TN = q0 + p      # parametrization of a neighbourhood around q0
    tr = 0.0:0.125:6pi

    @time xv = taylorinteg(pendulum!, q0TN, tr, 28, 1e-20, maxsteps=100);</code></pre><p>Note that the initial conditions <code>q0TN</code> are of type <code>TaylorN{Float64}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/explicitode.jl#L363-L429">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.taylorinteg-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{S}, Tuple{Any,S,T,U,Int64,V}} where V&lt;:Real where U&lt;:Real where T&lt;:Real where S&lt;:Number" href="#TaylorIntegration.taylorinteg-Union{Tuple{V}, Tuple{U}, Tuple{T}, Tuple{S}, Tuple{Any,S,T,U,Int64,V}} where V&lt;:Real where U&lt;:Real where T&lt;:Real where S&lt;:Number"><code>TaylorIntegration.taylorinteg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">taylorinteg(f, x0, t0, tmax, order, abstol; keyword... )</code></pre><p>General-purpose Taylor integrator for the explicit ODE <span>$\dot{x}=f(t,x)$</span> with initial condition specified by <code>x0</code> at time <code>t0</code>. The initial condition <code>x0</code> may be of type <code>T&lt;:Number</code> or a <code>Vector{T}</code>, with <code>T</code> including <code>TaylorN{T}</code>; the latter case is of interest for jet transport applications.</p><p>It returns a vector with the values of time (independent variable), and a vector (of type <code>typeof(x0)</code>) with the computed values of the dependent variable(s). The integration stops when time is larger than <code>tmax</code> (in which case the last returned values are <code>t_max</code>, <code>x(t_max)</code>), or else when the number of saved steps is larger than <code>maxsteps</code>.</p><p>The integration uses polynomial expansions on the independent variable of order <code>order</code>; the parameter <code>abstol</code> serves to define the time step using the last two Taylor coefficients of the expansions. Make sure you use a <em>large enough</em> <code>order</code> to assure convergence.</p><p>The current keyword argument is <code>maxsteps=500</code>.</p><p><strong>Examples</strong>:</p><ul><li>One dependent variable: The function <code>f</code> defines the equation of motion.</li></ul><pre><code class="language-julia">    using TaylorIntegration

    f(t, x) = x^2

    tv, xv = taylorinteg(f, 3, 0.0, 0.3, 25, 1.0e-20, maxsteps=100 )</code></pre><ul><li>Many (two or more) dependent variable: The function <code>f!</code> defines   the equation of motion.</li></ul><pre><code class="language-julia">    using TaylorIntegration

    function f!(t, x, dx)
        for i in eachindex(x)
            dx[i] = x[i]^2
        end
    end

    tv, xv = taylorinteg(f!, [3.0,3.0], 0.0, 0.3, 25, 1.0e-20, maxsteps=100 )</code></pre><p>Note that <code>f!</code> updates (mutates) the pre-allocated vector <code>dx</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/explicitode.jl#L203-L254">source</a></section><h2><a class="nav-anchor" id="Internal-1" href="#Internal-1">Internal</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.findroot!-NTuple{19,Any}" href="#TaylorIntegration.findroot!-NTuple{19,Any}"><code>TaylorIntegration.findroot!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">findroot!(g, t, x, dx, g_val_old, g_val, eventorder, tvS, xvS, gvS,
    t0, δt_old, x_dx, x_dx_val, g_dg, g_dg_val, nrabstol,
    newtoniter, nevents) -&gt; nevents</code></pre><p>Internal root-finding subroutine, based on Newton-Raphson process. If there is a crossing, then the crossing data is stored in <code>tvS</code>, <code>xvS</code> and <code>gvS</code> and <code>nevents</code>, the number of events/crossings, is updated. <code>g</code> is the event function, <code>t</code> is a <code>Taylor1</code> polynomial which represents the independent variable; <code>x</code> is an array of <code>Taylor1</code> variables which represent the vector of dependent variables; <code>dx</code> is an array of <code>Taylor1</code> variables which represent the LHS of the ODE; <code>g_val_old</code> is the last-before-current value of event function <code>g</code>; <code>g_val</code> is the current value of the event function <code>g</code>; <code>eventorder</code> is the order of the derivative of <code>g</code> whose roots the user is interested in finding; <code>tvS</code> stores the surface-crossing instants; <code>xvS</code> stores the value of the solution at each of the crossings; <code>gvS</code> stores the values of the event function <code>g</code> (or its <code>eventorder</code>-th derivative) at each of the crossings; <code>t0</code> is the current time; <code>δt_old</code> is the last time-step size; <code>x_dx</code>, <code>x_dx_val</code>, <code>g_dg</code>, <code>g_dg_val</code> are auxiliary variables; <code>nrabstol</code> is the Newton-Raphson process tolerance; <code>newtoniter</code> is the maximum allowed number of Newton-Raphson iteration; <code>nevents</code> is the current number of detected events/crossings.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/rootfinding.jl#L31-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">jetcoeffs!(eqsdiff!, t, x, dx, xaux)</code></pre><p>Mutates <code>x</code> in-place using the recursion relation of the derivatives obtained from the differential equations <span>$\dot{x}=dx/dt=f(t,x)$</span>.</p><p><code>eqsdiff!</code> is the function defining the RHS of the ODE, <code>x</code> contains the Taylor1 expansion of the dependent variables and <code>t</code> is the independent variable. See <a href="api.html#TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Any,Array{U,1},T,T,Int64,T}} where U&lt;:Number where T&lt;:Real"><code>taylorinteg</code></a> for examples and structure of <code>eqsdiff!</code>. Note that <code>x</code> is of type <code>Vector{Taylor1{U}}</code> where <code>U&lt;:Number</code>; <code>t</code> is of type <code>Taylor1{T}</code> where <code>T&lt;:Real</code>. In this case, two auxiliary containers <code>dx</code> and <code>xaux</code> (both of the same type as <code>x</code>) are needed to avoid allocations.</p><p>Initially, <code>x</code> contains only the 0-th order Taylor coefficient of the current system state (the initial conditions), and <code>jetcoeffs!</code> computes recursively the high-order derivates back into <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/explicitode.jl#L42-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U}}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U}}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.jetcoeffs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">jetcoeffs!(eqsdiff, t, x)</code></pre><p>Returns an updated <code>x</code> using the recursion relation of the derivatives obtained from the differential equations <span>$\dot{x}=dx/dt=f(t,x)$</span>.</p><p><code>eqsdiff</code> is the function defining the RHS of the ODE, <code>x</code> contains the Taylor1 expansion of the dependent variable(s) and <code>t</code> is the independent variable. See <a href="api.html#TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Any,Array{U,1},T,T,Int64,T}} where U&lt;:Number where T&lt;:Real"><code>taylorinteg</code></a> for examples and structure of <code>eqsdiff</code>. Note that <code>x</code> is of type <code>Taylor1{U}</code> where <code>U&lt;:Number</code>; <code>t</code> is of type <code>Taylor1{T}</code> where <code>T&lt;:Real</code>.</p><p>Initially, <code>x</code> contains only the 0-th order Taylor coefficient of the current system state (the initial conditions), and <code>jetcoeffs!</code> computes recursively the high-order derivates back into <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/explicitode.jl#L4-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T},AbstractArray{Taylor1{S},1},AbstractArray{Taylor1{S},1},Array{Taylor1{S},2},Array{Taylor1{S},3}}} where S&lt;:Number where T&lt;:Real" href="#TaylorIntegration.lyap_jetcoeffs!-Union{Tuple{S}, Tuple{T}, Tuple{Taylor1{T},AbstractArray{Taylor1{S},1},AbstractArray{Taylor1{S},1},Array{Taylor1{S},2},Array{Taylor1{S},3}}} where S&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_jetcoeffs!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lyap_jetcoeffs!(t, x, dx, jac, varsaux)</code></pre><p>Similar to <a href="api.html#TaylorIntegration.jetcoeffs!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1},AbstractArray{Taylor1{U},1}}} where U&lt;:Number where T&lt;:Real"><code>jetcoeffs!</code></a> for the calculation of the Lyapunov spectrum. Updates <em>only</em> the elements of <code>x</code> which correspond to the solution of the 1st-order variational equations <span>$\dot{\xi}=J \cdot \xi$</span>, where <span>$J$</span> is the Jacobian matrix, i.e., the linearization of the equations of motion. <code>jac</code> is the Taylor expansion of <span>$J$</span> wrt the independent variable, around the current initial condition. <code>varsaux</code> is an auxiliary array of type <code>Array{eltype(jac),3}</code> to avoid allocations. Calling this method assumes that <code>jac</code> has been computed previously using <a href="api.html#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}} where U&lt;:Number where T&lt;:Real"><code>stabilitymatrix!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/lyapunovspectrum.jl#L99-L111">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.lyap_taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},T,T,Array{U,1},Int64,T,Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},3},Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.lyap_taylorstep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">lyap_taylorstep!(f!, t, x, dx, xaux, δx, dδx, jac, t0, t1, x0, order, abstol, _δv, varsaux[, jacobianfunc!])</code></pre><p>Similar to <a href="api.html#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T}} where U&lt;:Number where T&lt;:Real"><code>taylorstep!</code></a> for the calculation of the Lyapunov spectrum. <code>jac</code> is the Taylor expansion (wrt the independent variable) of the linearization of the equations of motion, i.e, the Jacobian. <code>xaux</code>, <code>δx</code>, <code>dδx</code>, <code>varsaux</code> and <code>_δv</code> are auxiliary vectors. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to compute <code>jac</code>. Otherwise, <code>jac</code> is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/lyapunovspectrum.jl#L156-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U,T,Int64,Int64}} where T&lt;:Real where U&lt;:Number" href="#TaylorIntegration.nrconvergencecriterion-Union{Tuple{T}, Tuple{U}, Tuple{U,T,Int64,Int64}} where T&lt;:Real where U&lt;:Number"><code>TaylorIntegration.nrconvergencecriterion</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">nrconvergencecriterion(g_val, nrabstol::T, nriter::Int, newtoniter::Int) where {T&lt;:Real}</code></pre><p>A rudimentary convergence criterion for the Newton-Raphson root-finding process. <code>g_val</code> may be either a <code>Real</code>, <code>Taylor1{T}</code> or a <code>TaylorN{T}</code>, where <code>T&lt;:Real</code>. Returns <code>true</code> if: 1) the absolute value of <code>g_val</code>, the event function <code>g</code> evaluated at the current estimated root by the Newton-Raphson process, is less than the <code>nrabstol</code> tolerance; and 2) the number of iterations <code>nriter</code> of the Newton-Raphson process is less than the maximum allowed number of iterations, <code>newtoniter</code>; otherwise, returns <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/rootfinding.jl#L17-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.stabilitymatrix!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1}}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{TaylorN{Taylor1{U}},1},Array{TaylorN{Taylor1{U}},1},Array{Taylor1{U},2},Array{TaylorN{Taylor1{U}},1},Any}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.stabilitymatrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stabilitymatrix!(eqsdiff!, t, x, δx, dδx, jac, _δv[, jacobianfunc!])</code></pre><p>Updates the matrix <code>jac::Matrix{Taylor1{U}}</code> (linearized equations of motion) computed from the equations of motion (<code>eqsdiff!</code>), at time <code>t</code> at <code>x</code>; <code>x</code> is of type <code>Vector{Taylor1{U}}</code>, where <code>U&lt;:Number</code>. <code>δx</code>, <code>dδx</code> and <code>_δv</code> are auxiliary arrays of type <code>Vector{TaylorN{Taylor1{U}}}</code> to avoid allocations. Optionally, the user may provide a Jacobian function <code>jacobianfunc!</code> to compute <code>jac</code>. Otherwise, <code>jac</code> is computed via automatic differentiation using <code>TaylorSeries.jl</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/lyapunovspectrum.jl#L3-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.stepsize-Union{Tuple{U}, Tuple{T}, Tuple{Taylor1{U},T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.stepsize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">stepsize(x, epsilon) -&gt; h</code></pre><p>Returns a maximum time-step for a the Taylor expansion <code>x</code> using a prescribed absolute tolerance <code>epsilon</code> and the last two Taylor coefficients of (each component of) <code>x</code>.</p><p>Note that <code>x</code> is of type <code>Taylor1{T}</code> or <code>Vector{Taylor1{T}}</code>, including also the cases <code>Taylor1{TaylorN{T}}</code> and <code>Vector{Taylor1{TaylorN{T}}}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/explicitode.jl#L88-L98">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Taylor1{T},Taylor1{T},Int64}} where T&lt;:Number" href="#TaylorIntegration.surfacecrossing-Union{Tuple{T}, Tuple{Taylor1{T},Taylor1{T},Int64}} where T&lt;:Number"><code>TaylorIntegration.surfacecrossing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">surfacecrossing(g_old, g_now, eventorder::Int)</code></pre><p>Detect if the solution crossed a root of event function <code>g</code>. <code>g_old</code> represents the last-before-current value of event function <code>g</code>; <code>g_now</code> represents the current value of event function <code>g</code>; <code>eventorder</code> is the order of the derivative of the event function <code>g</code> whose root we are trying to find. Returns <code>true</code> if <code>g_old</code> and <code>g_now</code> have different signs (i.e., if one is positive and the other one is negative); otherwise returns <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/rootfinding.jl#L1-L10">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Array{Taylor1{U},1},Array{Taylor1{U},1},Array{Taylor1{U},1},T,T,Array{U,1},Int64,T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.taylorstep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">taylorstep!(f!, t, x, dx, xaux, t0, t1, x0, order, abstol) -&gt; δt</code></pre><p>One-step Taylor integration for the ODE <span>$\dot{x}=dx/dt=f(t, x)$</span> with initial conditions <span>$x(t_0)=x_0$</span>, computed from <code>t0</code> up to <code>t1</code>, returning the time-step of the actual integration carried out and updating (in-place) <code>x0</code>.</p><p>Here, <code>f!</code> is the function defining the RHS of the ODE (see <a href="api.html#TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Any,Array{U,1},T,T,Int64,T}} where U&lt;:Number where T&lt;:Real"><code>taylorinteg</code></a> for examples and structure of <code>f!</code>), <code>t</code> is the independent variable, <code>x</code> contains the Taylor expansion of the dependent variables, <code>x0</code> corresponds to the initial (and updated) dependent variables and is of type <code>Vector{Taylor1{T&lt;:Number}}</code>, <code>order</code> is the degree used for the <code>Taylor1</code> polynomials during the integration and <code>abstol</code> is the absolute tolerance used to determine the time step of the integration.  <code>dx</code> and <code>xaux</code>, both of the same type as <code>x0</code>, are needed to avoid allocations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/explicitode.jl#L161-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U},T,T,U,Int64,T}} where U&lt;:Number where T&lt;:Real" href="#TaylorIntegration.taylorstep!-Union{Tuple{U}, Tuple{T}, Tuple{Any,Taylor1{T},Taylor1{U},T,T,U,Int64,T}} where U&lt;:Number where T&lt;:Real"><code>TaylorIntegration.taylorstep!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">taylorstep!(f, t, x, t0, t1, x0, order, abstol) -&gt; δt, x0</code></pre><p>One-step Taylor integration for the ODE <span>$\dot{x}=dx/dt=f(t, x)$</span> with initial conditions <span>$x(t_0)=x_0$</span>, computed from <code>t0</code> up to <code>t1</code>. Returns the time-step of the actual integration carried out and the updated value of <code>x0</code>.</p><p>Here, <code>f</code> is the function defining the RHS of the ODE (see <a href="api.html#TaylorIntegration.taylorinteg-Union{Tuple{U}, Tuple{T}, Tuple{Any,Any,Array{U,1},T,T,Int64,T}} where U&lt;:Number where T&lt;:Real"><code>taylorinteg</code></a> for examples and structure of <code>f</code>), <code>t</code> is the independent variable, <code>x</code> contains the Taylor expansion of the dependent variable,<code>x0</code> is the initial value of the dependent variable, <code>order</code> is the degree  used for the <code>Taylor1</code> polynomials during the integration and <code>abstol</code> is the absolute tolerance used to determine the time step of the integration. Note that <code>x0</code> is of type <code>Taylor1{T&lt;:Number}</code> or <code>Taylor1{TaylorN{T}}</code>. If the time step is larger than <code>t1-t0</code>, that difference is used as the time step.</p></div></div><a class="source-link" target="_blank" href="https://github.com/PerezHz/TaylorIntegration.jl/blob/2275727767013ae7b288eb00ac5ba68ec3087121/src/explicitode.jl#L123-L141">source</a></section><footer><hr/><a class="previous" href="common.html"><span class="direction">Previous</span><span class="title">Interoperability with <code>DifferentialEquations.jl</code></span></a></footer></article></body></html>
